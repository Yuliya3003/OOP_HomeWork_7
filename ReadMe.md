# Принципы SOLID в данном коде
## Принцип единственной ответственности (Single Responsibility)
Каждый класс в этом коде создан для выполнения конкретной задачи:
- **Product:** Отвечает только за представление и хранение данных о продукте
- **WarehouseManager:** Отвечает за управление товарами на складе, предоставляя методы для увеличения, уменьшения, добавления и удаления товаров. 
- **Warehouse:** Реализует интерфейс WarehouseManager и отвечает за управление товарами на складе. Также генерирует начальный набор товаров при создании.
- **DegradableProduct:** Расширяет класс Product, добавляя дополнительное поле expirationDate, отвечающее за срок годности.
- **OrderManager:** Определяет метод для обработки заказа.
- **Order:** Реализует интерфейс OrderManager и обрабатывает заказы, управляя товарами на складе.

## Принцип открытости/закрытости (Open/Closed Principle - OCP)
Классы в коде спроектированы таким образом, чтобы быть открытыми для расширения (добавления нового функционала) и закрытыми для модификации. Например, можно легко расширить функциональность системы, добавив новые типы продуктов или методы обработки заказов, не изменяя существующий код.
## Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)

Классы в коде используют полиморфизм, позволяя заменять объекты одного типа объектами другого типа, производного от него, не нарушая работу программы. Например, DegradableProduct является подтипом Product и может использоваться везде, где ожидается тип Product.

## Принцип разделения интерфейса (Interface Segregation Principle - ISP)

Интерфейсы в коде разделены на более мелкие и специфичные, что позволяет клиентам использовать только те методы, которые им действительно нужны. Например, WarehouseManager и OrderManager определяют набор методов, не перегружая клиентов неиспользуемой функциональностью.

## Принцип инверсии зависимостей (Dependency Inversion Principle - DIP)

Классы в коде зависят от абстракций, а не от конкретных реализаций, что позволяет легко изменять их поведение, подменяя одну реализацию другой. Например, Order зависит от абстракции WarehouseManager, а не от конкретного класса Warehouse, что позволяет легко заменить или расширить реализацию склада без изменения кода Order.